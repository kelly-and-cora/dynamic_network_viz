
<!DOCTYPE html>
<meta charset="utf-8">
<style>
.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}
.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}
</style>
<svg width="960" height="600"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-timer.v1.min.js"></script>
<script>
  //var timer = d3.timer(callback);
  // var t = d3.timer(function(elapsed) {
  //   console.log(elapsed);
  //   if (elapsed > 3000) t.stop();
  // }, 150);

  var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");
  var color = d3.scaleOrdinal(d3.schemeCategory20);
  var simulation = d3.forceSimulation()
      .force("link", d3.forceLink().id(function(d) { return d.id; }))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2));

  var nodes = [];
  var links = [];
  var node;
  var link;

  d3.json("dist/time1_json.json", function(error, graph) {
    if (error) throw error;
    console.log('graph',graph.nodes)
    nodes = graph.nodes;
    links = graph.links;
    loadGraph(nodes, links);
  })


  function loadGraph(nodes, links) {
    var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke-width", function(d) { return Math.sqrt(d.value); });
    var node = svg.append("g")
      .attr("class", "nodes")
      .selectAll("circle")
      .data(nodes)
      .enter().append("circle")
        .attr("r", 5)
        .attr("fill", function(d) { return color(d.gender); })
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    node.append("title").text(function(d) { return d.id; });

    simulation
        .nodes(nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(links);

    function ticked() {
      link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });
      node
          .attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    }
  }

  // function restart(filename) {
  //   d3.json("dist/time1_json.json", function(error, graph) {
  //     // Apply the general update pattern to the nodes.
  //     node = node.data(nodes, function(d) { return d.id;});
  //     node.exit().remove();
  //     node = node.enter().append("circle").attr("fill", function(d) { return color(d.id); }).attr("r", 8).merge(node);
  //
  //     // Apply the general update pattern to the links.
  //     link = link.data(links, function(d) { return d.source.id + "-" + d.target.id; });
  //     link.exit().remove();
  //     link = link.enter().append("line").merge(link);
  //
  //     // Update and restart the simulation.
  //     simulation.nodes(nodes);
  //     simulation.force("link").links(links);
  //     simulation.alpha(1).restart();
  //   }
  // }


  // var iteration = 1;
  // var t = d3.timer(function(elapsed) {
  //   var filename = "dist/time" + iteration + "_json.json";
  //   ++iteration;
  //   if (iteration === 4) t.stop();
  //   console.log("iteration", iteration);
  //   restart(filename);
  // }, 1000);
  //
  // function loadGraph(filename) {
  //
  // }

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }
  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
</script>
